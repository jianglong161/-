232
1.为什么查询速度会变慢
	真正重要的是响应时间
	如果要优化查询
		实际上是优化其子任务
		要么消除其中一些子任务
		要么减少子任务的执行次数
		要么让子任务执行的更快
2.慢查询基础：优化数据访问
	查询性能低下最基本原因是访问的数据太多
	对于低性能查询需要分析两个步骤：
		1.确认应用程序是否在检索大量超过需要的数据
		2.确认MySQL服务器层是否在分析大量超过需要的数据行。
	2.1.是否向数据库请求了不需要的数据
		查询不需要的记录
			MySQl却是先返回全部结果在进行计算
			分页的时候在查询的后面加入limit
		多表关联的时候返回全部列
		重复查询相同的数据
			查询的时候将数据缓存起来，需要的时候从缓存中取出，这样性能更好
	2.2.MySQL是否在扫描额外的记录
		在确定只返回的数据以后，
		查询为了返回结果是否扫描了过多的数据
		对于MYSQL,最简单衡量查询开销的三个指标：
			响应时间：
				服务时间
					数据库处理这个查询花了多少时间
				排队时间
					因为等待某些资源而没有真正执行查询时间
				可以通过快速上限估计来估算查询的响应时间
			扫描行数
			返回行数
		扫描行数与访问类型
			评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本
			在Explan语句中type列反映了访问类型
			访问类型：
				全表扫描
				索引扫描
				范围扫描
				唯一索引查询
				常数引用
				速度由慢到快，扫描的行数也是由小到大
			如果查询没有办法找到合适的访问类型，那么解决问题的办法是通常增加一个合适的索引。
			索引让MySql以最高效，扫描行数最少的方式找到需要的记录
			一般MYSQL能够使用如下3种方式应用where条件，从好到坏：
				1.在索引中使用where语句来过滤不匹配的记录，这时在存储引擎中完成的
				2.使用索引覆盖扫描(在Extra中出现了Using index)来返回记录
				  直接从索引中过滤不需要的记录并返回命中的结果，是在MySQ服务器中完成的，但是无需再回表中查询记录
				3.从数据表中返回记录，然后过滤不满足的记录(在Extra中出现 Using where)
				  这在MySql服务器中完成的，MySql需要先从数据表中读出记录，然后过滤。
			如果发现查询需要扫描大量的数据只是返回少数的行，那么通常可以尝试下面的技巧去优化它
				使用索引覆盖扫描，把所有需要的列都放到索引中，那这样存储引擎无须回表获取对应行就可以返回结果
				改变库表的结构。例如使用单独的汇总表
				重写这个复杂的查询
3.重构查询的方式
	3.1.一个复杂的查询还是多个简单的查询
		MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢的多，
		在其他条件相同的时候，使用尽可能少的查询是最好的
	3.2.切分查询
		将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果
		定期清理大量数据的时候，如果使用一个大的语句一次性完成的话，可能需要一次性锁住很多数据，沾满整个日志，耗尽资源
	3.3.分解关联查询
		可以对每个表进一次单表查询，然后将结果在应用程序中进行关联
		用分解关联查询的方式重构查询有如下优势：
			让缓存效率更高
			将查询分解后，执行单个查询可以减少锁的竞争
			在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
			查询效率本身也有提升
			可以减少冗余记录的查询
			更进一步，这样做相当于在应用中实现了哈希关联
4.执行查询的基础
	1).客户端发送了一条查询给服务器
	2).服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓冲中的结果，否则进入下一阶段
	3).服务器进行sql解析，预处理，再由优化器生成对应的执行计划
	4).Mysql根据优化器生成的执行计划，调用存储引擎的API来进行查询
	5).将结果返回个客户端
	4.1.MySql客户端/服务器通信协议
		半双工
		查询状态
			使用show Full PROCESSLIST
			sleep
				线程正在等待客户端发送新的请求
			Query
				线程正在查询或者正在将结果发送给客户端
			Locked
				该线程正在等待表锁
			Analyzing and statistics
				线程正在手机存储信息，并生成查询计划
			Copying to temp table on disk
				线程正在执行查询，并且将结果集都复制到一个临时表中，
				这种状态要不是做GROUP By操作，要么是文件排序操作，或者是UNION操作
				如果这种状态后面还有on disk ，那表示MySQL正在将一个内存临时表放到磁盘上
				线程正在对结果集排序
			Sending data
				这表示多种情况：
					线程可能在多个状态中传送数据，或者生成结果集，或者在客户端返回数据
	4.2.查询缓存
		会优先检查这个查询是否命中查询缓存中的数据
		这个检查是通过一个对大小写敏感的哈希表查找来实现的
		如果当前查询命中了缓存中的查询，那么在返回结果之前MySQL会检测一次用户权限，这仍然无法解析
	4.3.查询优化处理
		查询的生命周期的下一步是将一个SQL转换成一个执行计划
		MYSQL在照这个执行计划和存储引擎进行交互
		包括许多子阶段：
			解析sql
			预处理
			优化sql执行计划
		语法解析器和预处理：
			通过关键字将sql进行解析，并生成一颗对应的解析树
			MYSQL解析器将使用MYSQL语法规则验证和解析查询
			预处理则是根据一些Mysql规则进一步检测解析树是否合法
				将检查数据表和数据列是否存在，还会解析名字和别名
			下一步预处理会验证权限，
		查询优化器
			现在语法树被认为是合法的，并且由优化器转化为执行计划
			优化器就是找到这其中最好的执行计划
			可以通过查询当前会话的"Last_query_cost"的值来得知MySql计算当前查询的成本
			有多种原因导致MysQL优化器选择错误的执行计划
				统计信息不准确
				执行计划中的成本估算不等于实际执行的成本
				MySql从不考虑其他并发执行的查询
			优化策略可以简单的分两种：
				静态优化
					可以直接对解析树进行优化
				动态优化
					则和查询的上下文有关
		MySql能够处理的优化类型：
			重新定义关联表的顺序
			将外连接转换成内链接
			使用等价交换原则
			优化COUNT(),MIN()和MAX()
				要找到某一列的最小值，只要查询B-Tree索引的最左端记录
			预估并转化为常数表达式
			覆盖索引扫描
			子查询优化
			提前终止查询
			等值传播
			列表IN()的比较
				MySql将in()列表的数据先排序，然后通过二分查找的方式来确定列表中的值是否满足条件，
				这是一个O(log N)复杂度的操作，等价地转换成OR查询的复杂度为O(n),对于In表有大量数据的时候，MySQl的处理速度会块
		数据库和索引的统计信息
			MySQL查询优化器在生成查询的执行计划的时候，需要向存储引擎获取相应的统计信息
		MySQL如何进行关联查询
			在MYSQL中，每个查询，每个片段都是有可能是关联
			对于UNION查询
				MYSQL先将一系列的单个查询结果放到一个临时表中，
				然后在重新读出临时表中的数据来完成UNION查询
			MySql执行关联的策略非常简单：
				MySql对任何关联都执行嵌套循环关联操作，
				即MYSQL先在一个表中循环出单条数据，
				然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到所有表中匹配的行为止。
				然后在根据各个表匹配的行，返回查询中需要的列。
				MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表中无法找到更多的行以后，会返回到上一层
			按照这样的方式查找第一个表记录，在嵌套查询下一个关联表，然后在回溯到上一个表
		执行计划
			MYSQL生成的查询的一颗指令树，然后通过存储引擎执行来完成这颗指令树并返回结果
			如果对某个查询执行EXPLAIN EXTEDED后，在执行SHOW WARRINGS 就可以看出重构出的查询
		关联查询优化器
			决定了多个表的关联时候的顺序
			通过不同顺序的成本选择一个代价最小的关联顺序
			当需要关联的表超过optimizer_search_depth的限制的时候，就会选择贪婪的模式，
		排序优化
			如果排序的数量小于排序缓冲区，MySQL使用内存快速排序
			如果内存不够，那么MYSQL会先将数据分块，对每个独立的块使用快速排序，并将每个块的排序结果放在磁盘上，最后进行合并
	4.4.查询执行引擎
		MySQL的查询引擎则是根据这个执行计划来完成整个查询
		执行计划是一个数据结构
		MYSQL在优化阶段就为每个表创建了一个 handler实例，优化器根据这些实例接口可以获取表的相关信息
	4.5.返回结果给客户端
		如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存当中
		MYSQL将结果集返回客户端是一个增量，逐步返回的过程
5.MYSQL优化器的局限性
	5.1.关联子查询
		最糟糕一类是Where语句中包含in
		如何用好关联子查询
	5.2.UNION的限制
		在每个字句中加入limit
	5.3.为什么查询速度会变慢
	真正重要的是响应时间
	如果要优化查询
		实际上是优化其子任务
		要么消除其中一些子任务
		要么减少子任务的执行次数
		要么让子任务执行的更快
2.慢查询基础：优化数据访问
	查询性能低下最基本原因是访问的数据太多
	对于低性能查询需要分析两个步骤：
		1.确认应用程序是否在检索大量超过需要的数据
		2.确认MySQL服务器层是否在分析大量超过需要的数据行。
	2.1.是否向数据库请求了不需要的数据
		查询不需要的记录
			MySQl却是先返回全部结果在进行计算
			分页的时候在查询的后面加入limit
		多表关联的时候返回全部列
		重复查询相同的数据
			查询的时候将数据缓存起来，需要的时候从缓存中取出，这样性能更好
	2.2.MySQL是否在扫描额外的记录
		在确定只返回的数据以后，
		查询为了返回结果是否扫描了过多的数据
		对于MYSQL,最简单衡量查询开销的三个指标：
			响应时间：
				服务时间
					数据库处理这个查询花了多少时间
				排队时间
					因为等待某些资源而没有真正执行查询时间
				可以通过快速上限估计来估算查询的响应时间
			扫描行数
			返回行数
		扫描行数与访问类型
			评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本
			在Explan语句中type列反映了访问类型
			访问类型：
				全表扫描
				索引扫描
				范围扫描
				唯一索引查询
				常数引用
				速度由慢到快，扫描的行数也是由小到大
			如果查询没有办法找到合适的访问类型，那么解决问题的办法是通常增加一个合适的索引。
			索引让MySql以最高效，扫描行数最少的方式找到需要的记录
			一般MYSQL能够使用如下3种方式应用where条件，从好到坏：
				1.在索引中使用where语句来过滤不匹配的记录，这时在存储引擎中完成的
				2.使用索引覆盖扫描(在Extra中出现了Using index)来返回记录
				  直接从索引中过滤不需要的记录并返回命中的结果，是在MySQ服务器中完成的，但是无需再回表中查询记录
				3.从数据表中返回记录，然后过滤不满足的记录(在Extra中出现 Using where)
				  这在MySql服务器中完成的，MySql需要先从数据表中读出记录，然后过滤。
			如果发现查询需要扫描大量的数据只是返回少数的行，那么通常可以尝试下面的技巧去优化它
				使用索引覆盖扫描，把所有需要的列都放到索引中，那这样存储引擎无须回表获取对应行就可以返回结果
				改变库表的结构。例如使用单独的汇总表
				重写这个复杂的查询
3.重构查询的方式
	3.1.一个复杂的查询还是多个简单的查询
		MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢的多，
		在其他条件相同的时候，使用尽可能少的查询是最好的
	3.2.切分查询
		将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果
		定期清理大量数据的时候，如果使用一个大的语句一次性完成的话，可能需要一次性锁住很多数据，沾满整个日志，耗尽资源
	3.3.分解关联查询
		可以对每个表进一次单表查询，然后将结果在应用程序中进行关联
		用分解关联查询的方式重构查询有如下优势：
			让缓存效率更高
			将查询分解后，执行单个查询可以减少锁的竞争
			在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
			查询效率本身也有提升
			可以减少冗余记录的查询
			更进一步，这样做相当于在应用中实现了哈希关联
4.执行查询的基础
	1).客户端发送了一条查询给服务器
	2).服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓冲中的结果，否则进入下一阶段
	3).服务器进行sql解析，预处理，再由优化器生成对应的执行计划
	4).Mysql根据优化器生成的执行计划，调用存储引擎的API来进行查询
	5).将结果返回个客户端
	4.1.MySql客户端/服务器通信协议
		半双工
		查询状态
			使用show Full PROCESSLIST
			sleep
				线程正在等待客户端发送新的请求
			Query
				线程正在查询或者正在将结果发送给客户端
			Locked
				该线程正在等待表锁
			Analyzing and statistics
				线程正在手机存储信息，并生成查询计划
			Copying to temp table on disk
				线程正在执行查询，并且将结果集都复制到一个临时表中，
				这种状态要不是做GROUP By操作，要么是文件排序操作，或者是UNION操作
				如果这种状态后面还有on disk ，那表示MySQL正在将一个内存临时表放到磁盘上
				线程正在对结果集排序
			Sending data
				这表示多种情况：
					线程可能在多个状态中传送数据，或者生成结果集，或者在客户端返回数据
	4.2.查询缓存
		会优先检查这个查询是否命中查询缓存中的数据
		这个检查是通过一个对大小写敏感的哈希表查找来实现的
		如果当前查询命中了缓存中的查询，那么在返回结果之前MySQL会检测一次用户权限，这仍然无法解析
	4.3.查询优化处理
		查询的生命周期的下一步是将一个SQL转换成一个执行计划
		MYSQL在照这个执行计划和存储引擎进行交互
		包括许多子阶段：
			解析sql
			预处理
			优化sql执行计划
		语法解析器和预处理：
			通过关键字将sql进行解析，并生成一颗对应的解析树
			MYSQL解析器将使用MYSQL语法规则验证和解析查询
			预处理则是根据一些Mysql规则进一步检测解析树是否合法
				将检查数据表和数据列是否存在，还会解析名字和别名
			下一步预处理会验证权限，
		查询优化器
			现在语法树被认为是合法的，并且由优化器转化为执行计划
			优化器就是找到这其中最好的执行计划
			可以通过查询当前会话的"Last_query_cost"的值来得知MySql计算当前查询的成本
			有多种原因导致MysQL优化器选择错误的执行计划
				统计信息不准确
				执行计划中的成本估算不等于实际执行的成本
				MySql从不考虑其他并发执行的查询
			优化策略可以简单的分两种：
				静态优化
					可以直接对解析树进行优化
				动态优化
					则和查询的上下文有关
		MySql能够处理的优化类型：
			重新定义关联表的顺序
			将外连接转换成内链接
			使用等价交换原则
			优化COUNT(),MIN()和MAX()
				要找到某一列的最小值，只要查询B-Tree索引的最左端记录
			预估并转化为常数表达式
			覆盖索引扫描
			子查询优化
			提前终止查询
			等值传播
			列表IN()的比较
				MySql将in()列表的数据先排序，然后通过二分查找的方式来确定列表中的值是否满足条件，
				这是一个O(log N)复杂度的操作，等价地转换成OR查询的复杂度为O(n),对于In表有大量数据的时候，MySQl的处理速度会块
		数据库和索引的统计信息
			MySQL查询优化器在生成查询的执行计划的时候，需要向存储引擎获取相应的统计信息
		MySQL如何进行关联查询
			在MYSQL中，每个查询，每个片段都是有可能是关联
			对于UNION查询
				MYSQL先将一系列的单个查询结果放到一个临时表中，
				然后在重新读出临时表中的数据来完成UNION查询
			MySql执行关联的策略非常简单：
				MySql对任何关联都执行嵌套循环关联操作，
				即MYSQL先在一个表中循环出单条数据，
				然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到所有表中匹配的行为止。
				然后在根据各个表匹配的行，返回查询中需要的列。
				MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表中无法找到更多的行以后，会返回到上一层
			按照这样的方式查找第一个表记录，在嵌套查询下一个关联表，然后在回溯到上一个表
		执行计划
			MYSQL生成的查询的一颗指令树，然后通过存储引擎执行来完成这颗指令树并返回结果
			如果对某个查询执行EXPLAIN EXTEDED后，在执行SHOW WARRINGS 就可以看出重构出的查询
		关联查询优化器
			决定了多个表的关联时候的顺序
			通过不同顺序的成本选择一个代价最小的关联顺序
			当需要关联的表超过optimizer_search_depth的限制的时候，就会选择贪婪的模式，
		排序优化
			如果排序的数量小于排序缓冲区，MySQL使用内存快速排序
			如果内存不够，那么MYSQL会先将数据分块，对每个独立的块使用快速排序，并将每个块的排序结果放在磁盘上，最后进行合并
	4.4.查询执行引擎
		MySQL的查询引擎则是根据这个执行计划来完成整个查询
		执行计划是一个数据结构
		MYSQL在优化阶段就为每个表创建了一个 handler实例，优化器根据这些实例接口可以获取表的相关信息
	4.5.返回结果给客户端
		如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存当中
		MYSQL将结果集返回客户端是一个增量，逐步返回的过程
5.MYSQL优化器的局限性
	5.1.关联子查询
		最糟糕一类是Where语句中包含in‘’
		如何用好关联子查询
	5.2.UNION的限制
		在每个字句中加入limit
	5.3.索引合并优化
		查询条件越来越多的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行
	5.4.等值传递
	5.5.并行绕行
		别花时间尝试并行运行
	5.6.哈希关联
	5.7.松散索引扫描
	5.8.最大值和最小值
		最小值排序，limit 1
	5.9.在同一表上查询和更新
		不允许同时更新和查询，
		可以使用生成表的形式绕过上面的限制
6.查询器优化提示
	HIGHT_PRIORITY和LOW_PRIORITY
		这个提示告诉MYSQL，多个语句同时访问一张表的时候，那些语句的优先级相对高一些，哪些语句的优先级相堆低一些
		HIGHT_PRIORITY用于SELECT语句的时候，MYSQL会降SELECT语句重新调度到有正在等待表锁以便修改数据的语句时
		LOW_PRIORITY会让一些语句一直处于正在等待的状态，只要队列中还需要访问同一个表的语句的时候
	DELAYED
		这个提示对INSERT和REPLACE
		该提示会让LAST_INSERT_ID()无法正常工作
	STRAIGHT＿JOIN
		可以放到SELECT语句的SELECT的关键字以后
7.优化特定类型查询
	7.1.优化COUNT()查询
		COUNT()的作用
			统计某个列值的数量，也可以统计某个行数
			统计列值时要求列值非空
			
		查询条件越来越多的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行
	7.2.优化关联查询
		确保on或者using字句上有索引。
		  在创建索引的时候要考虑到关联的顺序
		当表A和表B用列c关联的时候，如果优化器关联是BA,那么就不需要在B表上建立索引
	7.3.优化子查询
		尽可能使用关联来替代子查询
	7.4.优化GROUND BY 或者DiStiance
	7.5.优化limit 分页
	7.9.使用用户自定义变量
			set @one = 1，然后可以在任何表达式中使用他们
			使用自定义变量查询，无法使用查询缓存
			不能在使用常量或者标识符的地方使用自定义变量，例如表名
			生命周期是在一个连接中有用
		