索引和算法
1.InnoDB存储引擎索引概述
	B+书索引
		类似二叉树，根据key-value快速找到数据。
		并不能找到一个给定key-value的具体行
		只能找到被查找数据行所在的页。然后通过数据库把页读入到内存，在内存查找，最后得到查找数据
	全文索引
	哈希索引
		InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引
2.数据结构与算法
	2.1.二分查找法
		将记录按有序化排列，在查找的方式中采用跳跃试来查找
		先以有序中的中点的位置为比较对象
		如果查找的元素小于该中点元素，则放到左边，否则放到右边，通过一次比较，将查找的区间是缩小一半。
	2.2.二叉查找数和平衡二叉树
		B+树是通过二叉查找树，在由平衡二叉树，B树演化而来。
3.B+树
	B+树由B树和索引顺序访问方法
	是为磁盘或其他直接存取辅助设备设计的一种平衡树
	在B+树中所有的记录节点都是按键值的大小顺序存放到同一层的叶子及节点上，
	由各叶子节点指针进行连接
	3.1.B+树的插入动作
		必须保证插入后节点的记录依然排序，同时需要考虑插入B+树的三种情况
	3.2.B+树的删除动作
4.B+树索引
	就是B+树在数据库中的实现
	分为聚集索引和辅助索引
	内部都是B+树索引，内部都是B+树，即高度平衡，叶子节点存放着所有数据
	不同的是叶子子点存放的是否是一整行的信息
	4.1.聚集索引
		InnoDB储存引擎表是索引组织表，即表中的数据按照主键顺序存放。
		聚集索引就是按照每张表的主键构造一颗B+树，同时叶子子点中存放即为整张表的行记录数据，
		聚集索引的叶子点成为数据页。
		每个数据页都通过一个双向链表来进行链接。
	4.2.辅助索引
		叶子子点并不包含行记录的全部数据
		叶子节点除了包含键值以外，每个叶子子点中的索引行中还包含了一个书签bookmark
		该书签告诉InnoDB存储引擎哪里可以找到与索引想对应的数据
		辅助索引的书签就是相应行数据的聚集索引
		当通过辅助索引来来寻找数据的时候，引擎会遍历辅助索引并通过叶级别的指针获得主键索引的主键
	    通过
	4.3.B+树索引的分裂
	4.4.B+树索引管理
		索引管理
			索引创建
				alter Table tbl_name | add {index|key} {index_name} {index_type}
				alter table tbl_name drop primary key |drop {index|key} index_name 
			mysql数据库对于索引的添加或者删除这类ddl操作，过程：
				首先创建一个新的临时表，表结构为通过命令alter Table 新定义的结构
				然后把苑表中的数据导入临时表
				接着删除原始表
				最后把临时表名为原来的表名
			对于辅助索引的创建，InnoDB存储引擎会对创建索引的表上加个s锁
			在创建的过程中，不需要重建表
			删除的时候，只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除mysql数据库内部图上对该表的索引定义
			由于fic在索引创建的时候对表加上s锁，因此在创建的过程中，只能对该表进行读操作
			只限于辅助索引的操作，对于主键的的创建和删除需要建立新表
			实现osc，在线架构改变
				init:初始阶段，会对创建的表做一些验证工作，检查表是否有主键，是否存在触发器
				createCopyTable:创建和原始表一样的新表
				alterCopyTable:对新表进行Alter Table操作，如添加索引或列等
				createDeltasTable:创建deltas表，该表的作用是为下个触发器所使用
					之后对原表所有的DML操作会被记录到createDeltasTable表中
				cretaeTriggers:对原表Insert，update，delete操作的触发器，触发操作产生的记录被写入deltas表中
				startSnpshotXact：开始OSC操作的事物，
				selectTableIntoOutfile：将原表的数据写入到新表
				dropNCIIndexs:在导入新表前，删除新表中所有的辅助索引
				loadCopyTable:将导出的分片文件导入新表中
				replayChanges:将osc过程中原表DML操作记录到新表中
				recreateNCIndex:重新创建辅助索引
				replayChanges：再次进行DML日志的回访操作，这些日志在上述创建辅助索引的时候过程中产生了新的日志
				swapTable:将原表和新表家欢名字
	