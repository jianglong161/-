索引和算法
0.索引基础
	查询的时候现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行
	索引包含许多个列，那么列的顺序也非常重要，因为Mysql只能高效的使用索引的最左前缀列。
1.InnoDB存储引擎索引概述
	B+书索引
		类似二叉树，根据key-value快速找到数据。
		并不能找到一个给定key-value的具体行
		只能找到被查找数据行所在的页。然后通过数据库把页读入到内存，在内存查找，最后得到查找数据
		适用于全键值，键值范围或键前缀查找
		限制：
			如果不是按照索引的最左列开始查询，则无法使用索引
			不能跳过索引的列
			如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询
	全文索引
	哈希索引
		InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引
		只有精确匹配索引所有列的查询才有效
		对于每一行数据，索引列都会对所有的索引列计算一个哈希码，不同键值的行计算出来的哈希码一不一样
		只有Memory引擎支持哈希
		限制：
			哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
			哈希索引数据并不是按照索引值顺序存储的，无法排序
			哈希索引也不支持部分索引匹配查找
			哈希索引只支持等值比较查询，不支持任何范围内的查询
			访问哈希索引的数据非常快，除非有哈希冲突
			如果哈希冲突很多的话，一些索引维护操作的代价非常高
	空间数据表索引R-Tree
		MyISAM支持空间索引，用作地理数据的查询
		必须使用MySql的GIS相关函数如MBRCONTAINS()等来维护数据
	全文索引	
		是特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值
		适用于MATCH AGAINST操作，而不是普通的WHERE条件操作
2.数据结构与算法
	2.1.二分查找法
		将记录按有序化排列，在查找的方式中采用跳跃试来查找
		先以有序中的中点的位置为比较对象
		如果查找的元素小于该中点元素，则放到左边，否则放到右边，通过一次比较，将查找的区间是缩小一半。
	2.2.二叉查找数和平衡二叉树
		B+树是通过二叉查找树，在由平衡二叉树，B树演化而来。
3.B+树
	B+树由B树和索引顺序访问方法
	是为磁盘或其他直接存取辅助设备设计的一种平衡树
	在B+树中所有的记录节点都是按键值的大小顺序存放到同一层的叶子及节点上，
	由各叶子节点指针进行连接
	3.1.B+树的插入动作
		必须保证插入后节点的记录依然排序，同时需要考虑插入B+树的三种情况
	3.2.B+树的删除动作
4.B+树索引
	就是B+树在数据库中的实现
	分为聚集索引和辅助索引
	内部都是B+树索引，内部都是B+树，即高度平衡，叶子节点存放着所有数据
	不同的是叶子子点存放的是否是一整行的信息
	4.1.聚集索引
		InnoDB储存引擎表是索引组织表，即表中的数据按照主键顺序存放。
		聚集索引就是按照每张表的主键构造一颗B+树，同时叶子子点中存放即为整张表的行记录数据，
		聚集索引的叶子点成为数据页。
		每个数据页都通过一个双向链表来进行链接。
		一个表只能有一个聚集索引
		只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。
		优点：
			可以把相关数据保存在一起。
			数据访问更快。
			使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
		缺点：
			最大限度提高了I/O密集型应用的特点。如果全部数据都存放到内存中，访问顺序就不重要了
			插入的速度严重依赖插入顺序
			更新聚集索引的代价太高
			可能导致全表扫描变慢
			二级索引比较大
	4.2.辅助索引
		叶子子点并不包含行记录的全部数据
		叶子节点除了包含键值以外，每个叶子子点中的索引行中还包含了一个书签bookmark
		该书签告诉InnoDB存储引擎哪里可以找到与索引想对应的数据
		辅助索引的书签就是相应行数据的聚集索引
		当通过辅助索引来来寻找数据的时候，引擎会遍历辅助索引并通过叶级别的指针获得主键索引的主键
	    通过
	4.3.B+树索引的分裂
	4.4.B+树索引管理
		索引管理
			索引创建
				alter Table tbl_name | add {index|key} {index_name} {index_type}
				alter table tbl_name drop primary key |drop {index|key} index_name 
			mysql数据库对于索引的添加或者删除这类ddl操作，过程：
				首先创建一个新的临时表，表结构为通过命令alter Table 新定义的结构
				然后把苑表中的数据导入临时表
				接着删除原始表
				最后把临时表名为原来的表名
			对于辅助索引的创建，InnoDB存储引擎会对创建索引的表上加个s锁
			在创建的过程中，不需要重建表
			删除的时候，只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除mysql数据库内部图上对该表的索引定义
			由于fic在索引创建的时候对表加上s锁，因此在创建的过程中，只能对该表进行读操作
			只限于辅助索引的操作，对于主键的的创建和删除需要建立新表
			实现osc，在线架构改变
				init:初始阶段，会对创建的表做一些验证工作，检查表是否有主键，是否存在触发器
				createCopyTable:创建和原始表一样的新表
				alterCopyTable:对新表进行Alter Table操作，如添加索引或列等
				createDeltasTable:创建deltas表，该表的作用是为下个触发器所使用
					之后对原表所有的DML操作会被记录到createDeltasTable表中
				cretaeTriggers:对原表Insert，update，delete操作的触发器，触发操作产生的记录被写入deltas表中
				startSnpshotXact：开始OSC操作的事物，
				selectTableIntoOutfile：将原表的数据写入到新表
				dropNCIIndexs:在导入新表前，删除新表中所有的辅助索引
				loadCopyTable:将导出的分片文件导入新表中
				replayChanges:将osc过程中原表DML操作记录到新表中
				recreateNCIndex:重新创建辅助索引
				replayChanges：再次进行DML日志的回访操作，这些日志在上述创建辅助索引的时候过程中产生了新的日志
				swapTable:将原表和新表家欢名字
5.B+树索引的使用
	5.1.不同应用中B+树索引的使用
	5.2.联合索引
		对表上的多个列进行索引。
		已经对第二个键值进行了排序处理。
	5.3.覆盖索引
		从辅助索引中就可以查询的记录，而不需要查询聚集索引的记录。
		好处是辅助索引不包含整行记录的所有信息，所以大小要远远小于聚集索引
	5.4索引提示
6.哈希算法
	时间复杂度为O(1),且不只存在索引中，每个数据库都存在该数据结构
	6.1.哈希表
		解决了直接寻址的问题
		两个关键字同时映射到一个槽上，成为碰撞
		最简单的碰撞技术，成为连接法。
		都将关键字转换成自然数，然后通过除法散列，乘法散列或全域散列来实现
		数据库一半采用除法散列的方法
		在哈希函数的触发散列中，通过取k除以m的余数，将关键字k映射到m个槽的某个地方
	6.2.InnoDB存储引擎中的哈希算法
		用哈希算法对字典进行查找，其冲突机制采用链表方式，
		对于缓冲池页的哈希表来说，缓冲池中对的page页都有一个chain指针，它指向相同哈希函数值的页。
		m的取值略大于2倍的 缓冲池数量的质数。
	6.3.自适应哈希索引
		数据库自身创建并使用的
		show engine innodb status
7.全文搜索
	7.1.倒排索引
		在辅助表中存储了单词与单词自身在一个或多个文档所在位置的额映射，
		通常利用关联数组的实现
			inverted file index 表现形式为 单词，单词所在文档id
			full inverseted index 其表现形式为单词，单词所在文档的额id，在具体文档的位置
8.索引的优点
	索引大大减少了服务器需要扫描的数据量
	索引可以帮助服务器必买年排序和临时表
	索引可以将随机IO变为顺序IO
9.高性能索引策略
	9.1.独立的列
		如果查询的列不是独立，则Mysql就不会使用索引。
		独立的列指索引列不能是表达式一部分，也不能是函数的参数
	9.2.前缀索引和索引选择性
		索引的选择性
			不重复的索引值和数据表的记录总数的比值，索引的选择性越高则查询效率越高。
	9.3.多列索引
	