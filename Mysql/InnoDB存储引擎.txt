InnoDB存储引擎
	特点：行锁设计，支持MVCC，支持外键，提供一致性非锁定读，同时被设计成最有效的利用内存和cpu
后天线程：
	InnoDB数据库引擎是多线程的模型
	1.Master Thread
		非常核心的后台线程，将缓冲池的数据异步刷新到硬盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲池
	2.IO Thread
		使用大量Async IO来处理IO请求，主要工作负责这些IO的回调
	3.Purge Thread
		事物被提交以后，其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。
内存
	1.缓冲池
		InnoDB是基于磁盘存储，并将记录按照页的方式进行管理。
		将磁盘读到的页放入的缓冲池中，成为将页FIX缓冲池
		修改的时候先修改页，然后再以一定频率刷新到磁盘上。
		通过innoDB_buffer_pool_size
		数据类型有：
			索引页
			数据页
			undo页
			插入缓冲
			自适应哈希索引
			InnoDB存储的锁信息
			数据字典信息
		允许有多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中，能减少数据库的内部竞争，增加数据库的比并发处理能力
		通过InnoDB_buffer_pool_instance
	2.LRU List,Free List,Flush List
		数据库中的缓冲池通过LRU算法管理
			即频繁使用的页在前端，最少使用的页在尾端
			如果直接将直接读取的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，影响效率
			使用Innodb_old_blocks_time,用于表示读取到miu的页表示多久才能进入到LRU的前端。
			刚开始的时候LRU是空的，页都存放到free列表中
			当需要从缓冲池中分页时，，首先冲Free列表中查找是否有可能用的页，若有则从Free中删除，放入到LRU列表
			pages made young显示了维护LRU列表中页移动的前端次数
	3.重做日志缓冲
		先放到缓冲区，innodb_log_buffer_size ，默认8MB
		Master Thread 每一秒将重做日志缓冲刷新到重做日的文件
		每个事物提交会将重做日志缓冲刷新到重做日文件
		小于1/2’，重做日志缓存刷新到重做日志文件之中
	4额外的内存池
		内存管理通过内存堆中
CheckPoint技术
	事物提交的时候，先做日志，在修改页，由于宕机导致数据丢失的时候，通过重做日志来完成数据的恢复
	需要两个条件
		缓冲池可以缓存数据库所有的数据
		重做日志可以无线增大
	checkPoint检查点目的解决一下问题
		压缩数据库的恢复时间
		缓冲池不够用的时候，将脏页刷新到磁盘
		重做日志不可用的时候，刷新脏页。
Master Thread 工作方式
	Master Thread具有最高线程的有限级别，主要由
	主循环：通过thread sleep 实现，在负载很大的情况下会有延时。
		每秒的操作
			日志缓冲刷新到磁盘，即使这个事物还没有提交。（总是）
			合并插入缓冲   可能
			至多刷新100个InnoDb缓冲池到脏页到磁盘
			如果没有当前获得 切换到后天循环  可能
		每10秒的操作
			刷新100个脏页到磁盘 可能
			合并至多5个插入缓冲 总是
			将日志缓冲刷新到磁盘 总是
			删除无用的Undo页
			刷新100个或者10个脏页到磁盘
	后台循环：数据库空闲，或者数据库关闭，就会切到这个循环
		删除无用的Undo页 总是
		合并20个插入缓冲 总是
		调回到主循环
		不断刷新100个页直至符合条件
	刷新循环
	暂停循环
	会根据数据库运行的状态，在这些循环中来回切换。
InnoDB 关键特性
	插入缓冲 insert Buffer
		索引是辅助索引
		索引不是唯一的
		B+树
	两次写 Double Write
		带给数据页的可靠性
	自适应哈希索引 Adaptive Hash Index
		复杂度为O(1)
	异步IO
		可以进行IO Merge操作
	刷新邻接页 Flush Neighbor page
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		