锁
1.什么是锁
	锁是数据库区别与文件系统的一个关键特性
	使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。
2.lock与latch
	latch：对象是线程，保护的是数据结构，无死锁。
		成为闩锁，轻量级的锁，要求锁的时间特别短，若持续时间长，性能弱
		mutex互斥量，rwlock读写锁
	lock:对象是事务，用来锁定的是数据库的对象，表，页，行
		一般lock的对象仅在事务commit和rollback后进行释放
		有死锁机制
3.InnoDB存储引擎的锁
	3.1.锁的类型：
		InnoDB实现了如下的两种标准的行级锁
			共享锁 S lock：允许事务读一行
			排它锁 X lock:允许事务删除或者更新一行
		锁兼容:事务T1获得行r 共享锁，事务T2立即获得r的共享锁，因为读取并没有改变r的数据
		只是多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在。
		意向锁：为了支持不同粒度上的进行加锁操作：InnoDB支持一种额外的锁方式
				把锁定的对象分为更多的层次，希望在更细粒度上进行加锁，
				为表级别的锁，主要是在一个事务中揭示下一行将被请求的锁类型
				1.意向共享锁 ISlock 获得一张表的某几行的共享锁
				2.意向排它锁 IXlock 获得一张表的某几行的排它锁
	3.2.一致性非锁定读
		通过行多版本控制的方式俩读取当前执行时间数据库中行的数据
		如果读取的行正在执行DELETE或者UPDATE,读取的操作不会因此等待行上锁的释放
		会读取行的一个快照数据
		快照数据是改行之前版本的数据，通过undo来段完成，用来在事务中回滚数据
		读快照数据是不需要上锁的
	3.3.一致性锁定读
		select..... for update :对查询的数据加个x锁
		select.... lock in share mode：对读取的记录加个s锁
		必须在一个事务中，当 事务提交了，锁也就释放了，在使用上述两句的四时候
		务必加上begin start transaction 或者 set autocommit =0
	3.4.自增长与锁
		插入操作会依据这个自增长的计数器值加1赋予自增长列 成为Ant-ing Locking
		不是在一个事务中完成后才释放，而是在完成对自增长值的插入的SQL语句立即释放
		不过，并发性比较差
		insert.....select的大数据插入会影响性能，因为另一个事务中的插入会被阻塞。
		提供innodb_autonic_lock_mode来控制自增长的模式，默认值为1
		自增长值的列必须是索引，还得是索引的第一个列
	3.5.外键和锁
		外键主要运用完整性的约束检查
		对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎，自动会加一个索引，避免表锁
4.锁的算法
	4.1.锁的三种算法
		Record Lock：单个行记录上锁，总会锁定一个索引记录，没有索引，隐式的主键来进行锁定
		Gap Lock:间隙锁，锁定一个范围，但是不包括记录本身
			关闭Gap Lock
				将事务的隔离级别设置为READ COMMITTED
				将参数innodb_locks_unsafe_for_binlog设置为1
		Next-Key Lock:Record Lock+Gap Lock ,锁定一个范围，并且锁定记录本身。
			Next-Key Lock降级为Record lock仅在查询唯一索引的时候，若是辅助索引，完全不同
	4.2.解决Phantom Problem
		在默认的事务隔离中即，REPEATABLE READ,InnoDB存储引擎的锁采用Next-Key来避免幻想问题
		Phantom Problem，在同一事务下，连续执行两次sql语句可能导致不同的结果，
			第二次的sql可能会发返回之前不存在的行
5.锁问题
	通过锁机制可以实现事务的隔离性要求，锁只会带来3中问题
	5.1.赃读
		脏页是指在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，数据库内存中的页和磁盘的页不一样，
		脏数据，事务在缓冲池中已经修改的记录，并且没有提交。
		脏页的读取是整场 的，因为数据库的实例内存和磁盘的异步造成的，并不影响数据的一致性。
		  脏页都是异步的，不影响数据的可靠性，因此可以带来性能的提高。
		脏读指的就是在不同的事务中，当前事务可以阅读到另外事务未提交的数据
		脏读的发生条件事务的隔离级别READ UNCOMMITTED
	5.2.不可重复读
		不可重复读读到的已经提交的数据，违反了数据的一致性原则。
		数据的隔离级别为read COMMITED允许不可重复读的现象。
		在InnoDB，通过算法Next-Key lock来避免不可重复读的问题。
		 对于索引的扫描，不仅是锁住扫描的索引，还锁住这些索引的翼盖范围，因此这个范围的插入都是不可允许的
	5.3.丢失更新
		一个事务的更新操作被另一个事务的更新操作覆盖，导致数据的不一致。
		避免丢失更新操作，需要让事务在这种情况下的操作变成串行化
6.阻塞
	不同锁之间的兼容关系，在有些时刻，一个事务中的锁需要等待另一个事务中的锁释放它所占的资源
7.死锁
	7.1.两个或者两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象
		解决死锁就是不要有等待，将任何等待都转换成回滚，并且事务重新开始。
		解决死锁的最简单的方法是超时
		两个事务互相等待，当一个等待时间超过设置的某一阈值，其中一个事务进行回滚，另一个事务继续进行。
		当前数据库普遍采用wait-for graph等待图的方式进行死锁检测。保存两条信息
			锁的信息链表
			事务的等待链表
		通过上述链表可以构造一张图,如果这个图存在回路，就代表存在死锁。
		事务为图中的额节点
	7.2.死锁的概率	
		死锁的次数应该少于等待
		系统中事务的数量越多，发生死锁的概率越大
		每个事务操作的数量越多，发生的死锁的概率越大
		操作数据的集合，越小发生死锁的概率越大