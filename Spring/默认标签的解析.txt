默认标签的解析
默认标签的解析在parseDefaultElement，函数的功能一目了然，分别对四种标签进行处理
	import,alias,bean,beans
1.bean标签的解析与注册
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, 
						getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error("Failed to register bean definition with name '" +
						bdHolder.getBeanName() + "'", ele, ex);
			}
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
	(1).BeanDefinitionHolder类的parseBeanDefinitionElement进行元素解析，返回BeanDefinitionHolder类型的bdHolder
		经过这个方法后，bdHolder实例已经包含了配置文件的各种属性，例如，name,id,alias,之类的属性
	(2).不为空的情况下，若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。
	(3).解析完成需要对bdHolder进行注册，注册操作委托给BeanDefinReaderUtils的registerBeanDefinition()
	(4).最后发出响应事件，通知相关的监听器，这个bean加载完成
	1.1.解析BeanDefinition
		public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
			return parseBeanDefinitionElement(ele, null);
		}
		public BeanDefinitionHolder parseBeanDefinitionElement(Element ele,
			BeanDefinition containingBean) {
		String id = ele.getAttribute(ID_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

		List<String> aliases = new ArrayList<>();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}

		String beanName = id;
		if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isDebugEnabled()) {
				logger.debug("No XML 'id' specified - using '" + beanName +
						"' as bean name and " + aliases + " as aliases");
			}
		}

		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
		}

		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		if (beanDefinition != null) {
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
						String beanClassName = beanDefinition.getBeanClassName();
						if (beanClassName != null &&
								beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isDebugEnabled()) {
						logger.debug("Neither XML 'id' nor 'name' specified - " +
								"using generated bean name [" + beanName + "]");
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
	主要工作：
		提取元素的id以及name属性
		进一步解析所有属性，并封装到GenericBeanDefinition类的实例中
		如果检测到bean没有指定beanName，那么使用默认规则为此Bean生成BeanName
		将获取到的信息封装到BeanDefinationHolder
	第二个：进一步解析所有属性，并封装到GenericBeanDefinition类的实例中
		public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, BeanDefinition containingBean) {

			this.parseState.push(new BeanEntry(beanName));

			String className = null;
			//解析class属性
			if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
				className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
			}

			try {
				String parent = null;
				//解析Parent属性
				if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
					parent = ele.getAttribute(PARENT_ATTRIBUTE);
				}
				//创建用于承载属性AbstractBeanDefinition类型的GenericBeanDefinition
				AbstractBeanDefinition bd = createBeanDefinition(className, parent);
				//硬编码解析默认bean的各种属性
				parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
				//提取description
				bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
				
				//解析元素
				parseMetaElements(ele, bd);
				//解析lookup-method元素
				parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
				//解析ReplacedMethod元素
				parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

				parseConstructorArgElements(ele, bd);
				//解析property元素
				parsePropertyElements(ele, bd);
				//解析qualifier子元素
				parseQualifierElements(ele, bd);

				bd.setResource(this.readerContext.getResource());
				bd.setSource(extractSource(ele));

				return bd;
			}
			catch (ClassNotFoundException ex) {
				error("Bean class [" + className + "] not found", ele, ex);
			}
			catch (NoClassDefFoundError err) {
				error("Class that bean class [" + className + "] depends on not found", ele, err);
			}
			catch (Throwable ex) {
				error("Unexpected failure during bean definition parsing", ele, ex);
			}
			finally {
				this.parseState.pop();
			}

			return null;
		}
		1.创建用于属性继承的BeanDefinition
			BeanDefinition是个接口，存在三种实现：
				RootBeanDefinition
					是最常用的实现类，它对应一般的<bean>元素标签，
					父<bean>
				ChildBeanDefinition
				GenericBeanDefinition
					是一站式服务类
			都继承了AbstractBeanDefinition，其中BeanDefinition是配置文件<bean>元素标签在容器中内部的表现形式。
			  BeanDefinition与<bean>中的属性是一一对应的。
			spring通过BeanDefinition将配置文件的<bean>配置信息转换为容器的内部表示，
			并将这些BeanDefinition注册到BeanDefinitionRegistry中。
			spring的BeanDefinitionRegistry就像Spring配置信息的内存数据库，以map形势保存，
			  后续操作直接从BeanDefinitionRegistry读取配置信息
			要解析属性首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition
		2.解析各种属性
			当我们创建了bean信息的承载实例中后，便可以进行bean信息的各种解析了，
			首先进入的parseBeanDefinitionAttributes(),对element所有的元素属性进行解析。
			BeanDefinitionParserDelegate.parseBeanDefinitionAttributes(Element ele, String beanName,
			BeanDefinition containingBean, AbstractBeanDefinition bd)
		3.解析子元素meta
			meta：元数据，当需要使用里面的信息时可以通过key获取
			public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
				NodeList nl = ele.getChildNodes();
				for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {
					Element metaElement = (Element) node;
					String key = metaElement.getAttribute(KEY_ATTRIBUTE);
					String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
					BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
					attribute.setSource(extractSource(metaElement));
					attributeAccessor.addMetadataAttribute(attribute);
					}
				}
			}
		4.解析子元素lookup-method
			lookup-method：获取器注入，是把一个方法声明为返回某种类型的bean但实际要返回的bean是在配置文件里面配置的
		5.解析子元素
			replaced-method：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑
			parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides）
		