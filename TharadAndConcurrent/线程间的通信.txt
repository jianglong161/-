线程间的通信
使用wait/notify实现线程间的通信
生产者/消费者模式的实现
方法join的使用
ThreadLocal类的使用
3.1.等待/通知机制
	3.1.1.不使用等待通知机制实现线程之间的通信
		需要一种机制来减少CPU资源的浪费，而且还可以实现多个线程间的通信，它就是wait/notify
	3.1.2.什么是等待通知机制
	3.1.3.等待通知机制的实现
		wait()
			当前执行代码的线程进行等待。
			是Object类方法。用来将当前线程线程置入"预执行队列"中
			所在的代码行停止执行。直到接到通知或者被中断为止
			再调用之前，线程必须获得该对象的对象级锁。
			从wait()返回前，线程与其他线程竞争获得锁
			如果没持适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类。不需要trycath
		notify()
			在同步方法或者同步块中调用
			调用之前也要获得对象锁
			如果没持适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类。不需要trycath
			用来通知哪些可能等待对象的对象锁的其他线程
			如果有多个线程等待，则由规划器随机挑选出其中一个呈wait状态的线程。对其发送通知notify
			执行此方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify线程将程序执行完
			退出synchronized代码块，当前线程才会释放锁。
		wait使线程停止运行，而notify使线程继续运行
		新创建一个新的线程对象后，在调用start()，系统会为此线程分配cpu资源，使它处于Runnable可运行阶段，这是准备运行阶段
		   如果线程在抢占到cpu资源就变成Running运行状态
		线程进入Ruannable状态大体分为5种情况：
			调用sleep()方法后经过的事件超过了指定的休眠时间
			线程调用的阻塞IO已经返回，阻塞方法执行完毕
			线程成功的获得了试图同步的监视器
			线程正在等待某个通知，其他线程发送了通知
			处于挂起状态的线程调用resum()恢复方法
		出现阻塞情况大体分为5种
			线程调用sleep()，主动放弃占用的处理器资源
			线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞
			线程视图获得一个同步监视器，但该同步监视器正被其他线程锁持有
			线程等待某个通知
			程序调用了suspend()方法将该线程挂起。此方法容易导致死锁。
	3.1.4.wait()锁释放与notify()锁不释放
		wait()被执行后，锁被自动释放，但执行完notify()方法，锁却不自动释放，必须执行完notify()方法所在的同步synchronized代码块后才被释放。
	3.1.5.当interruupt方法遇到wait方法	
		当线程呈wait()状态时，调用线程对象interrupt()会出现InterruptedException
		执行完同步代码块就会释放对象的锁
		在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放
		在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放对象锁，而此线程就会进入线程等待池中，等待被唤醒。
	3.1.6.只通知一个线程
		调用notify()一次只会随机通知一个线程进行唤醒。
	3.1.7.唤醒所有线程
		notifyAll()
	3.1.8.方法wait(long)的使用
		等待某一时间是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。。
	3.1.9.通知过早
	3.1.10.等待wait的条件发生改变
	3.1.11.生产者/消费者模式的实现	
		1.一生产与一消费：操作值
		2.多生产与多消费：操作值-假死
			假死的现象其实就是线程进入WAiting等待状态。如果全部线程都进入Waiting状态
			则程序就不再执行任何业务功能，整个项目呈停止状态。
			唤醒了同类
		3.多生成多消费：操作值
			notifyAll()
		4.一生产与一消费：操作栈
		5.一生产与多消费-操作栈：解决wait条件改变与假死
		6.多生产与一消费：操作栈
		7.多生产与多消费:操作栈：
	3.1.12.通过管道及你想那个线程间通信：字节流
		管道流pipeStream是一种特殊的流，用于不同线程间直接传送数据。
		一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。
	3.1.13.通过管道进行线程间通信：字符流
3.2.方法join的使用
	主线程创建并启动子线程，如果子线程中要进行大量的耗时计算，主线程往往将早于子线程之间结束
	这时主线程想等待子线程执行完成以后在结束
	join()等待线程对象销毁。
	3.2.1.学习方法join前的铺垫
	3.2.2.用join()
		join()的作用是使所属线程对象x正常执行run()任务，而式当前线线程z进行无限期的阻塞，等待线程x销毁后在继续执行线程z后面的diamond
		具有是线程排队运行的作用
		join()在内部使用wait()方法进行等待
		synvhronized使用的是“对象监视器”原理做为同步
	3.2.3.方法join与异常
		在join过程中，如果当前线程对象被中断，则当前线程出现异常。
	3.2.4.join(long)
	3.2.5.join(long)与sleep(long)的区别
		join(long)的功能在内部是使用wait(long)方法来实现的，所以join(long)方法具有释放锁的特定
	3.2.6.方法join()后面的代码提前运行：出现意外
	3.2.7.方法join()后面的代码提前运行：解释以外(重点看)
3.3.类ThreadLocal的使用
	主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以储存每个线程的私有数据。
	3.3.1.get()和null
		累Threadlocal解决的是变量在不同线程间的隔离性，也就是不同吸纳成拥有自己的值，不同线程中的值是可以放入Threadlocal类中进行保存
	3.3.2.验证线程变量的隔离性
	3.3.3.解决get()返回null的问题
3.4.类InheritableThreadLocal的使用
	可以在子线程中取得父线程继承下来的值。
	3.4.1.值继承
	3.4.2.值修改
		如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改了，那么子线程取到的值还是旧值。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		