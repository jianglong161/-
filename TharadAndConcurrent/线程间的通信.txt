线程间的通信
使用wait/notify实现线程间的通信
生产者/消费者模式的实现
方法join的使用
ThreadLocal类的使用
3.1.等待/通知机制
	3.1.1.不使用等待通知机制实现线程之间的通信
		需要一种机制来减少CPU资源的浪费，而且还可以实现多个线程间的通信，它就是wait/notify
	3.1.2.什么是等待通知机制
	3.1.3.等待通知机制的实现
		wait()
			当前执行代码的线程进行等待。
			是Object类方法。用来将当前线程线程置入"预执行队列"中
			所在的代码行停止执行。直到接到通知或者被中断为止
			再调用之前，线程必须获得该对象的对象级锁。
			从wait()返回前，线程与其他线程竞争获得锁
			如果没持适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类。不需要trycath
		notify()
			在同步方法或者同步块中调用
			调用之前也要获得对象锁
			如果没持适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类。不需要trycath
			用来通知哪些可能等待对象的对象锁的其他线程
			如果有多个线程等待，则由规划器随机挑选出其中一个呈wait状态的线程。对其发送通知notify
			执行此方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify线程将程序执行完
			退出synchronized代码块，当前线程才会释放锁。
		wait使线程停止运行，而notify使线程继续运行
		新创建一个新的线程对象后，在调用start()，系统会为此线程分配cpu资源，使它处于Runnable可运行阶段，这是准备运行阶段
		   如果线程在抢占到cpu资源就变成Running运行状态
		线程进入Ruannable状态大体分为5种情况：
			调用sleep()方法后经过的事件超过了指定的休眠时间
			线程调用的阻塞IO已经返回，阻塞方法执行完毕
			线程成功的获得了试图同步的监视器
			线程正在等待某个通知，其他线程发送了通知
			处于挂起状态的线程调用resum()恢复方法
		出现阻塞情况大体分为5种
			线程调用sleep()，主动放弃占用的处理器资源
			线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞
			线程视图获得一个同步监视器，但该同步监视器正被其他线程锁持有
			线程等待某个通知
			程序调用了suspend()方法将该线程挂起。此方法容易导致死锁。
	3.1.4.wait()锁释放与notify()锁不释放
		wait()被执行后，锁被自动释放，但执行完notify()方法，锁却不自动释放，必须执行完notify()方法所在的同步synchronized代码块后才被释放。
	3.1.5.当interruupt方法遇到wait方法	
		当线程呈wait()状态时，调用线程对象interrupt()会出现InterruptedException
		执行完同步代码块就会释放对象的锁
		在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放
		在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放对象锁，而此线程就会进入线程等待池中，等待被唤醒。
	3.1.6.只通知一个线程
		调用notify()一次只会随机通知一个线程进行唤醒。
	3.1.7.唤醒所有线程
		notifyAll()
	3.1.8.方法wait(long)的使用
		等待某一时间是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		