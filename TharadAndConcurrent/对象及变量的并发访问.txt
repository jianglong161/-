对象及变量的并发访问
2.1.synchronized同步方法
	2.1.1.方法内的变量为线程安全
		非线程安全的问题存在与实例变量，如果是方法内部的私有变量，则不存在非线程安全。
	2.1.2.实例变量非线程安全
	2.1.3.多个对象多个锁
		关键字synchronized取得的锁都是对象锁，而不是把一段代买或函数当作锁
		 所以，哪个线程先执行带synchronized关键字方法,哪个线程就持有该方法所属对象的锁Lock
		 那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象
		如果多个线程访问多个对象，则jvm就会创建多个锁。
	2.1.4.synchronized方法与锁对象
		调用关键字synchronized()一定是排队运行的。
		只有共享资源的读写才需要同步
		A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法
		A线程先持有object对象Lock锁，B线程如果在时调用对象中的synchronized类型的方法则需等待，也就是同步
	2.1.5.脏读
		当线程调用anyObject对象加入synchronized关键字的X的方法时，A线程就获得了X的方法锁，更准确的讲，是获得了对象的锁。
		 所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用恰非synchronized同步方法。
		当线程调用anyObject对象加入synchronized关键字的X的方法时，A线程就获得了X的方法锁，更准确的讲，是获得了对象的锁。
		 所以其他线程必须等A线程执行完毕才可以调用X方法 ，B线程如果调用声明了synchronized关键字的非X方法,必须等A线程将x方法执行完以后，也就是释放对象锁才可以调用。
		脏读一定会出现操作实例变量
	2.1.6.synchronized锁重入
		当一个线程得到一个对象锁后，再次请求此对象锁时可以再次得到该对象的锁的
		锁重入：自己可以获得自己内部所。
				也支持在父子类中
	2.1.7.出现异常，锁自动释放
		当一个线程执行的代码出现异常时，其持有锁就会自动释放
	2.1.8.同步不具有继承性
2.2.synchronized 同步语句块
	A线程调用同步方法执行一个长时间的任务，那么B线程必须等待较长时间，可以使用synchronize同步语句块来解决。
	2.2.1.synchronized 方法的弊端
	2.2.2.synchronzied 同步块
		当两个并发线程访问同一个对象object中的synchronized同步块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完才能执行该代码块
	2.2.3.用同步代码块解决同步方法的弊端
	2.2.4.一半异步，一半同步
	不再synchronized块中就是异步执行，在synchronized块中就是同步。
	2.2.5.synchronized代码块间的同步性
	当一个线程访问object的一个synchronized（this）同步代码块时，其他线程对同一个object中所有的其他synchronized(this)同步代码块的访问将被阻塞
	 说明synchronized使用的“对象监视器” 是一个。
	2.2.6.验证同步synchronized(this)代码块是锁定当前对象
		 