对象及变量的并发访问
2.1.synchronized同步方法
	2.1.1.方法内的变量为线程安全
		非线程安全的问题存在与实例变量，如果是方法内部的私有变量，则不存在非线程安全。
	2.1.2.实例变量非线程安全
	2.1.3.多个对象多个锁
		关键字synchronized取得的锁都是对象锁，而不是把一段代买或函数当作锁
		 所以，哪个线程先执行带synchronized关键字方法,哪个线程就持有该方法所属对象的锁Lock
		 那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象
		如果多个线程访问多个对象，则jvm就会创建多个锁。
	2.1.4.synchronized方法与锁对象
		调用关键字synchronized()一定是排队运行的。
		只有共享资源的读写才需要同步
		A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法
		A线程先持有object对象Lock锁，B线程如果在时调用对象中的synchronized类型的方法则需等待，也就是同步
	2.1.5.脏读
		当线程调用anyObject对象加入synchronized关键字的X的方法时，A线程就获得了X的方法锁，更准确的讲，是获得了对象的锁。
		 所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用恰非synchronized同步方法。
		当线程调用anyObject对象加入synchronized关键字的X的方法时，A线程就获得了X的方法锁，更准确的讲，是获得了对象的锁。
		 所以其他线程必须等A线程执行完毕才可以调用X方法 ，B线程如果调用声明了synchronized关键字的非X方法,必须等A线程将x方法执行完以后，也就是释放对象锁才可以调用。
		脏读一定会出现操作实例变量
	2.1.6.synchronized锁重入
		当一个线程得到一个对象锁后，再次请求此对象锁时可以再次得到该对象的锁的
		锁重入：自己可以获得自己内部所。
				也支持在父子类中
	2.1.7.出现异常，锁自动释放
		当一个线程执行的代码出现异常时，其持有锁就会自动释放
	2.1.8.同步不具有继承性
2.2.synchronized 同步语句块
	A线程调用同步方法执行一个长时间的任务，那么B线程必须等待较长时间，可以使用synchronize同步语句块来解决。
	2.2.1.synchronized 方法的弊端
	2.2.2.synchronzied 同步块
		当两个并发线程访问同一个对象object中的synchronized同步块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完才能执行该代码块
	2.2.3.用同步代码块解决同步方法的弊端
	2.2.4.一半异步，一半同步
	不再synchronized块中就是异步执行，在synchronized块中就是同步。
	2.2.5.synchronized代码块间的同步性
	当一个线程访问object的一个synchronized（this）同步代码块时，其他线程对同一个object中所有的其他synchronized(this)同步代码块的访问将被阻塞
	 说明synchronized使用的“对象监视器” 是一个。
	2.2.6.验证同步synchronized(this)代码块是锁定当前对象
	2.2.7.将任意对象做为对象监视器
		synchronized同步方法
			对其他synchronized同步方法或synchronized(this)同步代码块呈阻塞作用。
			同一个时间只有亿i个线程可以执行synchronized同步方法中的代码
		synchronized(this)同步代码
			对其他synchronized同步方法或synchronized(this)同步代码块呈阻塞作用。
			同一个时间只有亿i个线程可以执行synchronized同步方法中的代码
		synchronized(非this对象)
			在多个线程持有“为同一个对象的前提下，统一时间只有一个线程可以执行synchronized(非this)”同
			 块代码
		锁非this对象具有一定的优点
			如果一个类中有很多synchronized方法，这时虽然能实现同步，但是会收到阻塞，影响效率
			使用同步发暧昧块非this对象，则synchronized非this代码块中的程序性与同步方法是异步的
			 不与其他锁this同步方法挣this锁，则可以大大提高运行效率。
	2.2.8.细化验证3个结论
		当多个线程同时执行synchronized(x){}同步代码块呈同步效果
		当其他线程执行x对象中synchronized同步方法时呈同步效果
		当其他线程执行x对象方法里面的synchronized(this)代码块时也呈现同步效果
	2.2.9.静态同步synchronized方法和synchronized(class)代码块
		关键字synchronized还可以应用在static静态方法上，如果这样写，那就是对当前的*.java文件对应的
		 Classl类进行持锁
		synchronized·加到非staic静态方法上是给对象上锁。
		异步的原因是持有不同的锁。
	2.2.10.数据类型String的常量池特性
		将synchronized(string) 同步块与String 联合使用时，要注意常量池以带来的一些例外
		String的值都是AA,两个线程持有相同的锁，所以线程B不能执行，在大多数情况下，同步synchronized
		 代码块都不使用String作为锁对象，而改用其他，比如new Object()
	2.2.11.同步synchronized方法无线等待与解决
		用同步块解决
	2.2.12.多线程的死锁
	2.2.13.内置类与静态内置类
	2.2.14.内置类与同步：实验1
	2.2.16.锁对象的改变
		在将任何数据类型作为同步锁，需要注意的是，是否有多个下昵称同时持有锁对象
		   如果同时持有相同的锁对象，则这些线程之间就是同步的
		   如果分别获得锁对象，这些线程之间就是异步的。
2.3.volatile关键字
	主要作用是使变量在多个线程间可见
	2.3.1.关键字volatile与死循环
	2.3.2.解决同步死循环
		volatile的作用就是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值
	2.3.3.解决异步死循环
		死循环的原因就是私有堆栈中的值和公共堆栈的值不同步造成
		volatile的作用就是强制从公共堆栈中取得变量的值，
		volatile和synchronized
			volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且
			  voliatile只能修饰于变量，synchronized可以修饰方法以及代码块。
			多线程volatile不会发生阻塞，而synvhronized会出现阻塞
			volatile能保证数据的可见性，但不能保证数据的原子性；而synchronized可以保证原子性，
			   也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步
			volatile解决的是变量在多个线程之间的可见性。而synchronized多个线程之间访问资源的同步性。
	2.3.4.volatile非原子性操作
		read和load阶段：从主内存复制变量到当前线程工作内存
		use和assign阶段：执行代码，改变共享变量的值，不是原子性
		store和write阶段：用工作内存数据刷新主存对应变量的值
	2.3.5.使用原子类进行i++操作
		除了i++操作时要使用synchronized关键字实现同步外，还可以使用AtomicInterger原子类
			private AtomicInterger coun = new AtomicInterger(0);
	2.3.6.原子类也并不完全安全
		原子类在具有有逻辑的情况下输出结果也具有随机性。
	2.3.7.synchronized代码块有volatitle同步的功能
		synchronized可以使多个线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的
		  私有变量与公共内存中的变量同步的功能。
		  可以保证在同一时刻，只有一个希艾娜成可以执行某一个方法或某一个代码块
		  包含两个特征：互斥性和可见性。
		  不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或者同步代码块的每个线程
		  都看到有同一个锁保护之前所有的修改对象。