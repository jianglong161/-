java内存区域与java内存溢出异常
1.1概述
	java虚拟机内存的各个区域
1.2.运行时的数据区域
	java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区。
	运行时数据区：
		由线程共享的数据区：
			方法区 Method Area
			堆 Heap
		线程隔离的数据区：
			虚拟机栈 VM Staack
			本地方法栈 Native Method Stack
			程序计数器
	1.2.1.程序计数器
		是一块较小的内存
		当前线程所执行的字节码的行号指示器
		字节码解释器的工作就是改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要这个计数器来完成。
		为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这类内存为线程私有。
		如果执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令地址
		如果执行的是native方法，计数器的值为空 Undefined
		次内存区域是唯一一个在java虚拟机规范中没有任何OutOfMemoryError情况的区域
	1.2.2.java虚拟机栈
		线程私有，生命周期与线程相同
		每个方法在执行时都会创建栈帧Stack Frame 用于存储
			局部变量表
				存放了编译期可知的各种节本数据类型，对象引用，refernce类型和returnAddress类型
				64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用一个。
				所需的内存空间在编译期间完成
				方法需要在栈中分配多大的局部变量空间是完全确定的。在运行期间不会改变局部变量表的大小
			操作数栈
			动态连接
			方法出口
		每个方法从调用直到执行完成的时候，就对应这一个栈帧在虚拟机找那个入栈到出栈的过程
		两种异常：
			如果线程请求的栈深度大于虚拟机锁允许的深度，抛出StackOverflowError
			如果虚拟机栈可以动态扩展，如果扩展时无法申请足够的内存，就会抛出OutOfMemoryError异常。
	1.2.3.本地方法栈
		与虚拟机栈的区别
			虚拟机栈为虚拟机执行java方法，也就是字节码服务。
			本地方法栈则为虚拟机使用的Native方法服务
	1.2.4.Java堆
		是java虚拟机管理内存中的最大的一块
		是被所有线程共享的一块内存区域
		在虚拟机创建的时候，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
		java堆是垃圾收集器管理的主要区域
		由于现在的收集器解百纳都采用分代收集算法，java堆分为：
			新生代
			老年代
		在细致分：
			Eden空间
			From Survivor空间
			To Surivivor空间
		可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。
		如果在堆中没有内存完成实例分配，并且堆也无法扩展时，就会抛出OutOfMemoryError异常。
	1.2.5.方法区
		是线程共享的内存区域
		存储已经被虚拟机加载的：
			类信息
			常量
			静态变量
			及时编译器变异后的代码等
		别名No-Heap
		成为永久代
		这区域内存回收目标主要是针对常量池的回收和对类型的卸载
		当方法区无法满足内存分配需求时，将抛出OutOfMemoryError
	1.2.6.运行时常量池
		是方法区的一部分
		Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池
		用于存放编译期的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
	1.2.7.直接内存
		并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
1.3.HotSpot虚拟机对对象探秘
	1.3.1.对象的创建
		在语言上创建对象仅仅是new关键字，在虚拟机中又是怎样一个过程
		虚拟机遇到一个new指令：
			首先检查这个指令参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。
			  如果没有必须先执行相应的类加载过程
			接下来虚拟机为新生对象分配内存
			    通过指针碰撞或空闲列表，选择哪种取决于java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
			内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，不包括对象头
				操作保证了对相爱呢个实例字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
			接下来对对象进行必要的设置
				对象属于哪个类，如果找到类的园数据等，对象的哈希码，对象的GC分代年龄等信息。
				这些信息存放在对象的对象头之中
			上述工作都完成，从虚拟机中看一个新的对象已经产生了，但从Java程序的视角来说，对象杆杠开始<init>方法还没执行，所有字段都还还为0
			执行完new指令后，接着执行<init>方法，把对象按照程序员的意愿初始化。
	1.3.2.对象的内存布局
		对象在内存中存储的布局可以分为3块区域：
			对象头：
				包括两部分信息：
					1.用云存储对象自身的运行时数据：
						如哈希码
						GC分代年龄
						所状态标志
						线程持有的锁
						偏向线程ID
						偏向时间戳
					2.类型指针
						即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例
					查找对象的元数据信息并不一定要经过对对象本身，
					如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据
					虚拟机可以通过普通java对象的元数据信息确定java对象的大小。
			实力数据
				部分是对象真正存储的有效信息，也是程序代码中锁定义的公众类型的字段内容
				存储顺序会收到虚拟机分配策略参数和字段在java源码中定义顺序的影响
			对齐填充
				不是必然存在的，起着占位符的作用
				自动内存管理系统要求对相爱呢个其实地址必须是8字节的整数倍，
				对象头部分正好是8字节的倍数。
	1.3.3.对象的访问定位
		建立对象是为了使用对象，我们java程序通过栈上的reference数据来操作堆上的具体对象
		目前主流的访问模式是：
			使用句柄：
				java堆会划出一块内存来作为句柄池，referernce中存储的就是对象的句柄地址
				句柄包含了对象昂实例数据与类型数据各自的具体地址信息
				最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
			使用指针
				java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。
				好处速度块，节省了一次指针定位的时间开销
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		