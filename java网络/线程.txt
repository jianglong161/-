线程
运行线程
	线程如果以小写字母t打头，这表示虚拟机中的一个单独，独立的执行路径。
	T,表示java.lang.Thread类的一个实例。
从线程返回信息
竟态条件
轮询
	让获取方法返回一个标志值，或者抛出一个异常，直到设置了结果字段为止。
	然后主线程定期询问这个获取方法，看看是否返回了标志之外的值
回调
	不是在主线程中重复询问每个ReturnDigest是否结束，而是让线程告诉主主线程它何时结束。
	通过调用主类（即启动线程这个类）中的一个方法来做到的，称为回调。
	线程在完成时反过来调用其创建者，这样以来主程序就可以在等待线程结束期间进行休息，而不会占用运行线程的时间
	当线程Run()接近结束的时候，要做的最后一件事就是好基于结果调用主程序中的一个已知方法	
	不是由主线程来询问每个线程答案，而是每个线程告诉主线程答案。
	相比轮询，回调机制的第一个优点就是不会浪费CPU周期，回调更灵活，可以处理涉及更多线程，对象和类的情况
	特定的对象可以调用通过Thread或Runnable类的一个方法把自己添加到这个列表中完成注册
Future，Callable和Executor
	可以隐藏细节使用回调
	直接创建一个ExecutorService，根据需要为你创建线程
	可以想ExecutorSerivce提交Callable任务
	对于每个任务，就会分配到一个Future，之后可以向Future请求得到任务结果
	如果结果已经准备就绪，就会立即取得到这个结果。
	如果还没有准备好，轮询线程会阻塞，直到结果准备就绪。
	Callable接口定义了一个call()方法，可以返回任意类型
		//将任务分解为两部分
		FindMaxTask task1 = new FindMaxTask(data, 0, data.length / 2);
		FindMaxTask task2 = new FindMaxTask(data, data.length / 2, data.length);
		
		//创建2个线程
		ExecutorService service = Executors.newFixedThreadPool(2);
		
		Future<Integer> future1 = service.submit(task1);
		Future<Integer> future2 = service.submit(task2);
		
		return Math.max(future1.get(), future2.get());
	会同时搜索这两个子数组，这个程序运行的速度几乎可达到之前的两倍
	调用future1.get()时，这个方法会阻塞，等待第一个FindeMaxTask完成，只有第一个FindMaxTask完成后，才会调用第二个future2.get()
同步
同步块
同步方法
同步的替代方式
	1.在可能的情况下，要使用局部变量而不是字段
		局部变量不窜在同步问题，每次进入一个方法的时候，虚拟机将为这个方法创建一组新的局部变量
		这些变量在方法外部是不可见的，而且方法退出时即将被撤销
		java是按值来传递参数，不是按引用来传递参数
		按值传递实际的参数是对象的引用
	2.在自己类中利用不可变性
		声明为private和final
	3.将非线程安全类用作为线程安全的类的一个私有字段。
		只要包含只以线程安全的方式方位这个非安全类，而且只要永远不让这个私有字段的引用泄漏到另一个对象中就是，那么这个类就是线程
		  安全
	有些情况使用java.util.cocurrent.atmoic包中特意设计保证线程安全可变
		不用int 使用AtmoicInteger
		不使用引用变量，而是把对象存储在一个AtomicReference中
死锁
	如果两个线程需要独占访问同样的一个资源集，而每个线程分别有这些资源的不同子集的锁，就会发生死锁
	避免不必要的同步
线程调度
抢占
	两种线程调度器
		抢占式
			确定一个线程正常的轮到其他CPU时间时，会暂停这个线程，将cpu控制权交给另外的线程
		协作式
			将cpu控制权交给其他线程前，会等待正在运行的线程自动暂停，
	为了让其他线程有机会运行，一个线程有10种方式可以暂停或指示它准备暂停，包括：
		可以对I/O阻塞
		可以对同步对象阻塞
		可以放弃
		可以休眠
		可以连接另一个线程
		可以等待一个对象
		可以结束
		可以被更高优先级线程抢占
		可以被挂起
		可以停止
阻塞
	任何时候线程必须停止下来等待它没有的资源的时候，就会发生阻塞
	要让网络上的线程自动放弃CPU的控制权，最常见的方法就是I/O阻塞
	无论是对I/O阻塞还是对锁阻塞，都不会释放线程已经拥有的锁
	I/O阻塞两种情况：
		最后I/O终将不再阻塞而线程继续执行；或者抛出异常，然后线程退出这个同步块或者方法，并释放它的锁。
	由于一个线程没有得到一个锁而阻塞，将永远不会放弃它自己的锁
放弃
	要让线程显式的放弃控制权使用Thread.yield()静态方法来做到
	放弃之前，线程应确保它或它关联的Runnable对象处于一致状态，可以由其他对象使用
	public void run(){
		while(true){
			//完成线程工作
			Thread.yield()
		}
	}
休眠
	放弃只是表示线程原因暂停，让其他拥有相同的优先级的线程有机会运行
	进入休眠的线程有所不同，不管有没有其他线程准备运行，休眠线程都会暂停
	进入休眠的线程仍然拥有它已经获得的所有锁，因此其他需要相同锁的线程会阻塞，即使cpu可用，所以要避免在同步方法或块内让线程休眠
	线程与Thread对象之间的区别
		一个线程在休眠，并不意味着其他唤醒线程不能处理这个线程相应的Thread对象
		具体，另一个对象可以调用休眠Thread对象的interrupt(),这会让休眠的线程得到一个InteruptedException
连接线程
	join()允许一个线程继续执行等待另一个线程结束
等待一个对象
	线程可以等待一个它锁定的对象
	在等待时会释放锁并暂停，直到它得到其他线程的通知
	调用它的线程会释放所等待的对象的锁，并进入休眠，线程会保持休眠，直到发生一下三种情况：
		时间到期
			timeout，当时间到期以后，线程会从紧挨着wait()调用之后的语句继续调用，不能立即获得锁，还要阻塞一段时间
		线程被中断
		对象得到通知
线程池和Executor
	利用java.util.concurrent中的Executor类，可以非常容易建立线程池
	  只要将各个任务作为一个Runnable对象交给这个线程池，你就会得到一个Future对象
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		